VimE 核心设计

    VimE 要做到设计目标（快速，可移植性），核心需要被仔细设计。VimE Core分为三
个子系统：输入系统，文件系统和显示系统：

         +---------------------------------------------------------+
  System |    key-cache          file-stream           Term/GUI    |
         +-------|--------------------|--------------------|-------+
       /         v                    v                    v
       | +---------------+    +---------------+    +---------------+                                
       | |    mappings   |    |   memcache    |    |     frame     |
       | |               |    |( undo / swap )|    |               |
       | +-------|-------+    +-------|-------+    +-------|-------+
  Core |         v                    v                    v
       | +---------------+    +---------------+    +---------------+  
       | |   operators   |--->|   encoding    |<---|     view      |
       | +-------|-------+<   +---------------+   >+-------|-------+
       |         v         \          ^          /         |        
       | +---------------+  \ +-------|-------+ /          |        
       | |  mode-stack   |   -|     hooks     |-           |
       | +---------------+    +-------|-------+            |        
       \                              v                    v
         +---------------+    +---------------+    +---------------+
 Plugins |   ops struct  |    |  enc-plugins  |    |    syntax     |
         +---------------+    +---------------+    +---------------+


    整个核心由六个系统组成。每个系统植根于一个 System 服务。


1. 输入子系统

    这个子系统是最小的一个子系统，负责的内容很少。就是管理用户的按键输入。用户
所有的按键被放到一个缓冲区里面（key-cache），然后根据当前的模式（mode），选择
不同的 mapping 子系统对key-cache的内容进行匹配。如果发现输入的某个内容是个映射
名，则根据这个映射名的标志位（flags）进行处理。

    一旦输入被确认为是无映射的输入，则所有内容会被送到 operator 子系统。对
VimE来说，所有的按键都是被作为 operator 的。甚至包括 insert 模式下输入内容的按
键。operator 实际上是个 hash 表（实现的时候商量一下，如果占用内存不大可以做成
一个 256 项的 1 比 1 映射表），所有的按键都对应一个操作，如果在表格中没有找到
对应的操作，则执行默认操作。在操作中返回特定值也会导致操作失效，使操作链的下一
个操作得以执行。如果所有的操作都无效，则最后默认操作仍然会被执行。大家可能想到
了， insert 模式下的默认操作就是插入字符本身。

    可以写针对 mappings 和 operators 的插件，用于添加 mappings 或者添加
operator 处理链。

    另外，VimE没有专门的 ex 命令层，ex 命令时特殊的 operator，它们以:开头。因
此在读到:字符的时候，会向模式栈中自动压入cmdline mode，然后进行cmdline mode的
处理。

2. 文件处理子系统

    这个系统是核心中的核心。当输入子系统需要响应命令时，它一般是对文件处理子系
统的最上层 encoding 子系统发送消息。encoding 子系统返回对应的缓冲区内编码后的
内容。它负责检查编码、提供编码长度等等的信息。

    encoding 子系统并不负责管理文件内容。它将输入子系统和显示子系统发出的命令
转交给 memcache 子系统，然后处理返回的内容。这个过程是这样做的：每一个注册的
encoding 子系统都必须填一个 encoding_ops 表格，填入自己的函数指针。然后
memcache 子系统同样需要填写一个 buffer_ops 表格。填入自己的指针。然后
encoding 子系统核心会获得这两个 ops，它先利用 buffer_ops 里面的函数获得自己需
要的 raw 数据。然后再使用 encoding_ops 表格里面的函数指针处理这些裸数据以完成
任务。

    memcache 子系统是 encoding 子系统的底层。它向 encoding 子系统提供数据。所
有的原始命令操作都是由 memcache 独力完成的。 buffer_ops 结构体提供了 memcache
所能完成所有操作的一个清单。在实现上，如果仅仅只有一个 memcache，那么省掉
buffer_ops 结构体。直接使用静态的函数以提高效率。

    memcache 负责处理所有的操作，比如插入字符（范围），删除字符（范围），替换
字符（范围），获取行长度，行偏移，书签的信息等等功能。memcache 内部还有两个非
常重要的子系统，是 undo 子系统和 swapfile 子系统。undo 子系统负责在 memcache
执行改变缓冲的操作时，将操作记录下来以供将来撤销。undo 是树状撤销的。因此对文
件作出的所有修改都会保留下来；swapfile 子系统是在处理大型文件中被使用的，当文
件过大，无法完全装入内存时，swapfile 负责将文件的一部分换出内存，装入交换文件
中。swapfile 子系统应该能够换出 memcache 的所有资源，包括文件数据块，行号缓存
，undo 树等等，并且能够提供在异常退出时恢复编辑操作的能力。

    memcache 子系统植根于 System 提供的 file-stream 子系统。这个子系统必须注册
一个 stream_ops 操作表，所有对文件流的操作都会被记录进去。尽管并不要求
stream_ops 能支持 seek 操作（虽然支持它本身也是鼓励的做法），但是用户仍然能够
向 memcache 子系统下达 seek 操作的命令，这是因为 memcache 子系统会记住所有读到
的内容。

    对于各个 *_ops 结构体的操作的特性和 operator 子系统的操作特性很像。因为它
们都是通过 hook 子系统提供实现的。因此可以进行链状处理。因此底层的 stream_ops
可以提供十分灵活的操作：比如读取目录、网络资源，甚至从别的进程读取数据。VimE的
可互操作性体现在这里：进程本质上只是一个 stream 而已。只是这个 stream 会另外提
供接口以写入数据。

    可以写针对文件处理子系统的插件。这些插件仍然会向 operator 子系统添加 hooks
以得到执行的机会，然后会用自己的 *_ops 表格替换掉标准的表格，然后用于处理。在
实现这样的技术时，插件可以自行通过链表实现 *_ops 栈，虽然 VimE 并没有在这方面
提供任何帮助，但是借助 VimE 的 Support/list.h 数据结构，实现这个功能也是十分简
单的。（注意：如果这样做了以后，那么 *_ops 实际上就是一个级联网式结构：如果在
一层的所有链中都无法处理，那么可以继续调用下一层的链进行处理，只有所有的链都无
法处理的时候，操作才会最终失败。）


3. 显示子系统

    显示子系统植根于 System 提供的 Term/GUI 服务。System 会提供 ui_ops 和
gui_ops 两个操作表格以供填写。ui_ops 用于最小的显示子系统，里面只会要求注册一
个串行终端所能提供的所有服务。而 gui_ops 继承自 ui_ops （gui_ops 包含 ui_ops
结构体，并且 ui_ops 结构体是 gui_ops 的第一个域）。

    这些 ops 首先由 frame 子系统使用，frame 子系统在 ops 提供的服务的基础上实
现 VimE 的窗口，标签页和框架服务。frame 子系统并不管理 VimE实际的显示，只是显
示状态栏、窗口、菜单、工具栏等等元素。实际的文本区的显示是由下级的 view 子系统
处理的。

    view 子系统尽力地利用从 encoding 子系统中获得的内容显示当前可以显示的部分
。并且向 memcache 子系统提供信息，以决定缓存的策略。

    view 子系统会实现抽象的“字符属性”特性。使得好像屏幕上的每个字符都有一个
属性一样。一般情况下字符属性是和每个字符相对应的，并且仅仅和屏幕有关，一旦字符
超出屏幕，字符属性也就丢失了，然而在没有超出屏幕时，所有的字符属性都会被保存。

    syntax 子系统则是用来解决 view 子系统的局限性的。它使用特殊的办法，将文本
组织成森林。每个字符属性并不是针对字符的，而是针对一颗字符树的。因此对一棵树中
的文字修改，并不会影响到其余任何树中的文字的属性。因此可以借此提供持久性的字符
属性。syntax 子系统会申请一个 memcache 服务，用于储存树形和树形的字符属性。因
此 syntax 的分析结果也是能够享受到 swapfile 服务的。虽然这样并不能得到恢复文件
内容的好处，但是可以作为 cache，提高访问树形字符属性的速度。

    这一层次中的插件用于补充 gui_ops 中的操作。gui_ops 会提供丰富的动画操作函
数。以保证 VimE 能体现现代的设计风格。另外插件也可以实现新的 syntax 模块，以提
供识别更多的文本的目的。syntax 模块可以自行分析文本，也可以调用外部程序分析。
因为有 memcache 作为缓存，因此即使是使用外部程序分析，速度也不会受到影响。

    另外，VimE 也允许开发 view 插件，它会增加屏幕上的字符属性的种类。并且能够
在显示某个特定属性的字符的时候提供自定义的方案。配合 syntax 插件可以达到十分惊
人的效果。 view 的具体实现是箱子式的。view 不管窗口中具体显示的是什么，对 view
来说，字符本身只有属性是重要的，而字符如何绘图 view 会根据属性调用属性中的 ops
操作。view 本身只会处理箱子和箱子之间的重叠问题。因此可以在添加新的属性和新的
ops 以实现特殊效果，比如在 view 中嵌入一幅图片。如果实现十分复杂的 view 插件，
甚至可以将 VimE 变成字处理器——虽然 VimE 是纯粹的文本编辑器，但是我们提供能扩
展 VimE 方式，而不让我们本身的定位影响 VimE 的使用方式。


可移植性

    要将 VimE 移植到其他平台，只需要提供 System 层的对应模块的实现即可。实现的
方法是这样的。在 lib/System 中会有一些 *.lst 文件，这些文件实际上是平台相关的
函数名。每一个 *.lst 文件对应于一个 lib/System/<T>/*.inc 文件。<T>是平台名称，
比如说 key-cache 子系统需要获得按键信息，这个信息是平台相关的，因此会有一个
lib/System/key-cache.lst 文件，里面有必须实现的函数名称（注意，只有函数名称是
平台相关的，所有的数据结构都必须是平台无关的，如果要使用平台相关的数据结构，需
要隐藏在 inc 文件中单独使用，不能出现在 lib/System/*.c 文件中），然后 Win32 的
实现会在 lib/System/Win32/key-cache.inc 文件中。在 lib/System/key-cache.c 中的
末尾会出现这样的代码：

#if defined(WIN32)
#include "Win32/key-cache.inc"
#elif defined(UNIX)
#include "UNIX/key-cache.inc"
#elif ...
....
#endif







