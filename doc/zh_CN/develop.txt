*develop.txt*	For VimE version 0.1.0	最近更新：2010年4月


		       VimE 参考手册    作者：StarWing


VimE 的开发						*development*

这一节讨论VimE的开发初衷，和设计规范，对开发 VimE 的人来说是很重要的。

1. 设计动机		|design-motivation|
2. 设计目标		|design-goals|
3. 设计决策		|design-decisions|
4. 编程风格		|coding-style|
5. 假定			|disign-assumptions|

请先看一下 "src" 目录下的 README.txt 以便能对 VimE 的设计架构有一定的了解。

VimE 继承自Vim，是开源软件，鼓励所有人加入以及改进。如果你想提交patch，请使用
"diff -c"来产生上下文 (context) 格式的 diff 文件。

==============================================================================
1. 设计动机						*design-motivation*

决定重头开始设计VimE不是为了重复造轮子，而是因为Vim的确有无法修正的缺陷，这无
法通过提交patch来改进。因此我们需要一个新的框架，先建立一个坚实的基础，然后慢
慢把Vim的代码填进来，同时控制质量，最终达到目标。

Vim的一些缺陷导致了VimE开发的最终进行：

	* 代码充斥了全局变量和草率的设计，各个部分高度耦合，很难添加新的功能或
	  者进行修改
	* Vim的设计决策决定了它必须兼容旧的Vi，而这导致Vim变得臃肿
	* 基础的一些算法并不优秀，并且欠缺考虑。比如直接以行为单位分配内存，却
	  不考虑行的大小，如果有行过长，则Vim反应缓慢
	* 脚本语言十分软弱，因为先天原因无法完全控制Vim的行为
	* 缺乏适当的二进制扩展机制，扩展Vim功能困难
	* 结构死板，无法支持更先进的编辑模式（如真正的实时hex编辑）和更先进的
	  概念（比如GUI Listbox popup和文法高亮，文法补全）。
	  ……

以上种种原因最终促使了VimE的开发，VimE的意思是Vi iMproved Expand，对其进行扩展
。不过这是终极目标，目前的VimE是Vim Emulater的意思，也就是目前要做到在速度和扩
展性上能与Vim竞争的程度，然后才会考虑兼容级别的扩展。


==============================================================================
2. 设计目标						*design-goals*

VimE目前分为三个设计阶段：

	* 在目前，只需要设计核心的Vi功能，保证基本的Vi功能得到实现。目标是尽量
	  的伸缩性和快速。要求能处理各种极限数据，能够达到理论上的最低复杂度。
	  主要的设计精力放在文件IO存取中，需要实现内存使用策略，显示策略和文件
	  的高速缓存，这个时期，代码必须自己完成，而且必须可扩展性，能提供增加
	  新功能的机制。

	* 在Vi核心的部分完成后，就开始进行Vim的兼容性开发了。核心不会改变，Vim
	  的兼容模式会以模块的形式提供。可以通过单独的dll，也可以直接编译进大
	  的程序。同时会考虑进行elisp源码级兼容的模块。

	* 在最后阶段，会开始进行VimE自己的脚本语言的开发了，不会有特别强大的特
	  性，但会改掉VimL里面的大部分不合理和有缺陷的地方。并在提供Vim兼容的
	  模式的情况下，鼓励使用新的VimEval语言书写插件——新的语言能够100%的
	  对编辑器的任何行为进行完全的配置，并会保持高的运行效率。


VimE的第一阶段会偶尔使用外部库，但这不是必须的，必要的时候会使用中间层去隔绝外
部库的影响。代码尽量分离成小块，并且在翻译级别间尽量减少相关性。具体的设计决策
和编程风格问题见|design-decisions|和|code-style|。


VIME 是 ... 高 速 的					*design-speed*

VimE必须在各种情况下都能保持很快的速度，采用可以利用的任何资源（多线程，llvm等
）保持启动、编辑、语法高亮等行为的高速，并且在低端的机器上和低速的串行线上也能
达到令人满意的使用效果。

任何一个特性，如果可能大幅降低VimE的效率，就不会被考虑，或者成为可选或模块。


VIME 是 ... 良 好 设 计 的				*design-wellformed*

VimE的设计之初就会考虑诸多特性，比如多线程安全，进程间协作，显示/操作分离等等
。具体会在设计决策里面仔细分析。首先，VimE会认真分离模块使用的API和自己的内部
API，尽量暴露简单的API，并且在绝大多数情况下使用公用的API。

VimE会尽量在配置选项允许的情况下，尽可能利用本地操作系统的所有优势，比如GUI，
网络套接字，进程间协作，多线程原语等等。但在核心代码中，并不会过多利用操作系统
特定的资源，所有的外部资源都会经过包装，成为可配置甚至是可动态启用的。目标是一
旦放入新的dll立即启用新的特性。

VimE会为内部高效的脚本语言留下足够的余地，关键点都会留下callback的方法以提供配
置的余地。VimE的各个舱会完全地分离，如果需要使用公共设施都会设置中间层，并通过
宏或者inline的方式尽量减少效率损失。注意本条不意味着VimE是臃肿的。这意味着VimE
必须在设计和速度方面有所均衡，任何设计都必须在考虑不是过度设计以后才会加入。


VIME 是 ... 高 可 扩 展 性 的				*design-flexible*

VimE是高可扩展的。不同于封闭的Vim，VimE会采用多种方式进行扩展。Vim的扩展最终只
会映射到内部的VimL以及ex-cmd上，除了通过别的编程语言提高效率以外无法提供多余的
灵活性。而VimE会提供多种方式的可配置性：
	
	* 最底层，可以使用ex-cmd进行配置，这会有最低的灵活性，但是会有最高的可
	  移植性。VimE会通过dll支持Vi，Vim和nvi的ex-cmd，因此可以提供最好的可
	  移植性。但是效率和灵活性会下降。

	* 稍微高一点层次，可以使用Vim-spec的脚本语言VimL。这涉及到大量Vim的内
	  建函数，运算符，if、while、for等等ex命令，这同样是使用dll提供扩展的
	  。VimL会提供更好的灵活性，但是效率会随着使用vim兼容模块而下降（比如
	  ，无法使用新的更快更强大的regex引擎）。

	* 再高一层次，可以使用VimE自建的脚本语言VimEval。它提供很高的灵活性和
	  效率，但是会和其他Vi的发布版不兼容。VimEval提供完全控制VimE的能力，
	  可以知道用户的每个操作，控制VimE内部的所有资源，但是如果用VimEval执
	  行某些高密度的操作——比如，进行全部的显示层构建——会导致效率变慢。
	  如果需要这样的需求，则VimEval是不合适的。VimEval的定位是VimL的快速替
	  代版。

	* 最高的层次是VimE的模块系统。模块系统使用动态链接库机制，模块本身是一
	  个动态链接库，因此以native code的代码的速度进行，效率和灵活性是最高
	  的。可以完全控制及改变VimE的任何行为，并且能直接替换掉VimE的任何服务
	  层。但是native code在不同操作系统和体系结构间可能会不兼容，因此只能
	  重新针对平台重新编译，可移植性不会很好，而且发布的时候可能需要采用源
	  代码发布才能提供某些可移植性。

VimE由数个子系统组成：文件IO处理，显示模块，输入模块，模式及命令子系统。这些子
系统是由明确定义的API互相调用的，可以动态地改变，而且各个子系统可能会有底层的
服务层，每个层之间会采用相同的方法提供替换的方式。因此VIME是高可扩展性的。


VIME 是 ... 高 可 移 植 性 的				*design-portable*

VimE会尽量利用各个操作系统的特性，但VimE是ad-hoc的，所有的特性都是热拔插的。而
核心仅采用clean C。因此是高度可移植的。VimE会提供操作系统抽象层API，仅需要实现
这些API就可以把VimE移植到任何提供键盘输入和终端输出的平台。根据平台提供的功能
多寡，还可以提供其他的抽象层API，以提供GUI等等其他的功能。


VIME 是 ... 自 由 的					*design-freedom*

目前Vim的开发比较死板，大家向Bram提交补丁，由Bram决定是否采纳。VimE会内置包管
理器。自动负责从脚本安装到模块编译的所有工作。这使得向VimE增加功能只需要向官方
的模块仓库增加新模块，而不用向VimE提交补丁。VimE的开发绝不会保持兼容性，但是一
旦有不兼容的改变，会通过模块的形式提供兼容行为，该兼容模块会在版本差大于2以后
停止维护，这样同时提供了兼容性和发展性。

在核心完成以后，VimE鼓励社区开发。这些工作不是作者一个人就能完成的，需要大家一
起努力。我们的目标是综合Emacs的优点（灵活性和完全可配置性）和Vim的优点（高效操
作），为了完成目的，我们欢迎任何人的任何形式的帮助。你可以帮忙提交脚本、模块；
修缮文档；书写wiki等等工作，我们会围绕编辑器建立活跃的社区。我们了解，与Vim高
度的兼容性才能开启这项工作，但这只是权宜之计。到最后，我们会主要致力于VimE本身
的功能提高，而不是与Vim的兼容。


VIME 不 是 ... 向 前 兼 容 的				*design-compatible*

VimE的设计初期完全不会考虑兼容性。兼容性会通过VimE的灵活性来提供。在完成初步的
设计（文件IO，基本操作的最小集合）之后，会通过模块的形式提供其他外部功能，其中
就包括兼容性。VimE会和Vim完全兼容，因为会提供100%使用原Vim代码的dll模块。


VIME 不 是 ... 操 作 系 统				*design-functional*

Vi使用者这么讽刺Emacs：“emacs就是一个操作系统。”VimE的目标不是提供万物的操作
系统。VimE致力于实现Vi的高效的指令操作集合的同时，提供最高的灵活性。VimE会通过
提供模块完成elisp的完整兼容。elisp的所有特性会被放在VimE的insert mode实现。它
会在 Vim兼容模式的同期完成。

VIME会提供目录操作、调试器协作、pty shell操作等等功能，但这只是为了在一个共同
的操作集合上高效地完成工作。VimE本身不会考虑去实现基本操作系统的逻辑和操作系统
的工具集合。虽然推荐和GNU工具箱一起使用VimE，但这不是强制性的，VimE的标准环境
也不会依赖任何操作系统提供的服务。


==============================================================================
3. 设计决策						*design-decisions*

VimE在设计初期就会有一些决策，这些决策可能会经过修改，但是不到万不得已，不会改
变。决策不似上面的设计目标，可以彼此权益。决策是VimE分支产生的根本原因，因此绝
不会权宜。但如果有充分的理由，也可以修改这些决策，但这需要社区所有骨干人员的一
致认同。


VIME 是 速 度 优 先 的					*decision-speed-first*

VimE的所有设计最先考虑的必须是速度。为了速度，可以采用处理器相关的等等不兼容方
式，但必须提供通用方法和编译期开关。任何特性，如果造成VimE产生人眼可见的效率差
别，都不会被考虑加入核心。如果在速度和灵活性之间做选择，VimE选择的永远是速度。
灵活性会作为编译期选项或者模块提供。VimE产生的根本目的就是emacs和Vim共同的缓慢
。达到最高的效率是VimE的终极目标。


VIME 是 高 度 灵 活 性 的				*decision-flexible*

当一个特性不涉及速度的考虑时，灵活性会被考虑。VimE会在任何关键点提供替代的方法
。为此可以不考虑内存的使用。但是VimE自己的内存使用会控制在用在文件缓冲区的内存
的10%以下。在这个基础上，任何能提高灵活性而对速度不会造成肉眼可察觉的设计都会
被接受。VimE是高度模块性的，并且即使在内部，这些模块之间的API也是清晰定义的，
因此可以随时偷换某些模块仍然使VimE能工作。VimE必须至少在一个平台上支持运行时的
可偷换性。保证除了kernel本身，所有的模块都可以被动态地禁用掉和替换掉，并且这些
替换和替换后的VimE是高效的。VimE计划提供一个最高效致密的核心，但外层所有的组件
都是不必须的，可以被轻易换掉。比如可以直接换掉显示层，把VimE变成一个hex编辑器
或者WYSIWYG的字处理器。虽然这不是设计重点，但是我们必须保证这种可能性的存在。


VIME 是 线 程 安 全 的					*decision-thread-safe*

VimE所有的代码都必须在多线程环境下安全。因为多线程是今后的发展。为了提高启动速
度，VimE会考虑在启动的时候就开始维护一个线程池，进行从读取脚本到分析输入文件的
所有工作。我们应该记住Emacs的低效。VimE的启动速度必须远超Vim，任何高于200ms的
启动速度都是不可容忍的。为了达到这个目标，提前给予操作界面，并在后台进行其他工
作是必须要考虑的。VimE所有的代码必须做到线程安全。VimE所有的核心数据结构必须提
供锁机制。


VIME 是 高 质 量 的					*decision-high-quality*

VimE的模块库会给予模块作者足够的自由。不会限制模块作者使用的语言、风格、实现、
策略。但是VimE的核心必须是高质量的。核心会采用clean C书写（即ANSI C89和ISO
C++03的一个子集）。VimE的核心会采用能非常容易嵌入任何程序的设计方法。我们会使
VimE的可执行镜像只是一个普通的，嵌入了VimE核心的程序。你可以把VimE通过DLL或者
源代码直接嵌入任何你想得到的程序，比如邮件接收程序，浏览器，聊天程序等等。甚至
在运行时，通过窗口替代你也可以做到这一点。想象一下你可以在你操作系统的任何一个
普通文本框里面使用VimE提供的服务吧。所以VimE的核心必须高质量，快速，可移植。


VIME 是 高 度 抽 象 的					*decsion-abstract*

VimE的核心不会考虑任何约定俗成的假定。VimE是高度抽象的，这是灵活性的基础。比如
在VimE中，操作是只针对数据的，而显示也是只针对数据的。因此显示和数据是完全分离
的。你可以通过替换不同的显示模式，从而使VimE瞬间看起来像另外一个程序。所有对显
示有要求的选项都不会对数据产生任何形式的变换。而对数据产生变换的操作不保证会在
显示上有任何可视的差别。

VimE同时是服务抽象的。VimE不提供策略，只提供机制。默认策略通过核心一个极小的实
现来提供。并且可以随时被模块所覆盖。VimE仅仅提供你想做事情的任何服务。比如在任
何输入模块都提供映射（map）抽象，VimE中不存在“普通模式映射”或“插入模式映射
”这些东西，VimE在任何可能接受输入的地方都能够采用映射，甚至是在文件输入输出中
（虽然这个设计会极端影响效率，但是VimE不会拒绝你这么做——只是VimE核心决不会这
么做），是否采用映射是由一个独立的映射服务提供的，它得到足够的信息，并对数据流
进行替换，而与你所在的模式无关。甚至模式本身都不是必须的，它只是对操作的一种抽
象。你可以在任何输入的地方都采用模式这种callback式的处理方式，VimE会提供高度Vi
兼容的默认模式实现，但这同样不是必须的，你可以随时整个替换掉这些模式。


VIME 是 有 活 力 的					*decision-energy*

VimE和VimE社区都是有活力的。我们不拒绝任何哪怕颠覆我们世界观的意见——只要这些
意见有实证能让VimE更加优秀。如果这些意见是偏激的，但的确是有效的。我们会考虑在
模块中提供这些设计方式。只有放之四海而皆准的修改意见我们才会接受并添加进核心。
VimE不拒绝任何不妨碍工作的进攻和讽刺，只要那的确是有道理，对VimE有益的。如果有
新的基于或者不基于VimE、提供比VimE更多的普适性和灵活性的项目，我们会全力支持。
我们的目的不是一个名字叫VimE的软件，我们的目的是获得世界上最好的文本编辑器。请
记住，让操作省掉一个按键，就是让全世界数百万的程序员一起少掉了数百万的按键。每
一个细小的改进都会被考虑。任何期望获得良好编辑器体验的行为我们都会支持与接受。
VimE会随着时代的发展而保持活性。只要世界上还没出现一款十全十美完全没有任何缺陷
的文本编辑器，那么VimE就有存在的价值。


功能备忘与特点						*decision-specfied*

VimE不以（行，偏移）二元组作为文件内位置单位。因此对一些Vim提供的功能，会采用
其他的实现。


	折叠和标记 ~

VimE支持按字节为单位的折叠。折叠是显示相关的，会单独在显示子系统中提供。折叠本
质上和标记mark一样。在逻辑上，mark和折叠都是面向字符流（而不是字节流）的。用一
个唯一的整数界定。如果产生了添加和删除，在添加删除区域之后的所有mark（包括折叠
）都会有相应位移，而如果mark在修改区域之中，则不会改变相对位移。比如： >
	foo|bar!
        ^    ^^
	1    23
<
有三个mark，而|代表光标位置。如果用户输入d2l，则会删除b和a字符，mark3会前移两
位，仍然在r上，而mark2会停留在感叹号上。

对mark可以添加标记，使当文本被删除时，mark也被同时删除。


	为窗口命名 ~

我们一般用"窗口"称呼很多东西，然而在VimE里面，我们需要很清晰的命名。窗口一般不
属于VimE核心，他们是VimE Layout服务层的一部分。下面是一些名词解释，注意他们和
在Vim中的解释不一样。

screen		整个屏幕。对于 GUI 来说，就是类似于 1024x768 像素之类的东西。
		VimE 可以使用整个屏幕（例如，在控制台运行的时候），也可以使用
		它的一部分（GUI，或者虚拟终端）。
frame		通常在GUI中被认为是“窗口”的东西，VimE支持多窗口的编辑。如果
		在终端中，你可以认为frame是类似于“预定义的窗口组合”的东西。
		因为你一次只能显示一个frame，但你可以在不同的frame里面放入不同
		的窗口组合，从而迅速切换另一种组合形式。在GUI中，只有frame才能
		包含minibuffer（即cmdline）、菜单和工具栏。
tab		标签页，在终端里面它和frame很相像，但是它会在页面的最上方或最
		下方提供一行标签列表，通过单击鼠标或者命令可以切换不同的标签页
		。在GUI中，它独占一个frame，并提供图形显示的标签，可以通过单击
		来改变显示的标签。
window		用来查看缓冲区的地方。VimE的window和Vim中的完全一样。
vscreen		虚拟屏幕，指的是对buffer来说，被认为是整个屏幕的东西。它只是
		buffer自认为的显示方式，甚至可能不会被真正显示出来。一个buffer
		每个buffer都认为自己独占了整个屏幕的显示。
buffer		文件缓冲区。它是“数据”的抽象。所有的文本（包括VimE消息，命令
		行历史等）都存在某一个buffer里面。buffer可以和一个window关联，
		buffer通常都有关联一个vscreen，但也可以不关联。这种情况下
		buffer是不可显示的，也就是不能和一个window想关联。


	自动完成和语法高亮 ~

把他们放在一起，是因为VimE会采用和Vim完全不同的方式进行语法高亮。语法高亮实际
上是一个动态的文法分析器。它本身是不会做任何事情的，仅仅提供基于正则表达式和
BNF的文法分析服务。但是它会提供钩子机制。任何一个文法被识别都会引发一个钩子被
调用（钩子也是VimE的子系统之一，用作自动命令和ad-hoc的实现），从而进行某些动作
，比如对屏幕内容定义格式，或者保存某些特殊结构。于是VimE的语法高亮从一开始就被
设计为根据文法进行高亮（比如，在一个函数里面foo是一个变量，则按照变量着色，而
另一个函数里面没有这个变量，于是foo按照通常的方式着色）。同时，也会有数个钩子
用于收集如整个文件所含单词等等的信息，用于补全操作。他们都不是核心的组成部分。
但是通常情况下会被静态编译。


	拼写检查和建议 ~

拼写检查构建在语法高亮模块上，会采用独立的方式进行处理，主要的方式是进程间协作
，见下。


	缩进和风格整理 ~

不同于Vim，VimE不会内置cindent机制了。它会将缩进完全交给外部进程或模块。因为
VimE内建进程间通讯机制，因此输入的文本会被on-the-fly地缩进，而且不止是当前行。
比如如果你输入行数过长，会被自动缩进到正确的行和正确的位置。如果你输入的行是一
个列表，根据外部程序的参数，甚至会自动将本行分割成多行，在删除一个字符后自动还
原。


	扩展和模块管理 ~

VimE会内建模块管理器，能方便的在buffer内就挂载、禁用、添加、删除新的模块和脚本
。会采用统一的方式提供脚本的运行，不需要再在脚本中提供检测二次运行的方式。常用
功能可以直接和VimE核心编译在一个做成一个大的应用程序，也可以直接被编译成dll。
注意在后一种模式中，VimE核心和与之共同编译的模块必须被编译成一个大的dll，被小
的bin所加载。否则模块无法使用核心提供的服务。在操作系统允许的情况下，用户可以
监视模块的线程数，占用内存等等信息，从而决定是否使用该模块。


	进程间协作

VimE核心会提供足够的进程间协作原语。包括socket套接字，共享内存和管道以及任何操
作系统提供的机制。进程间协作通过两个层面进行。首先VimE的某个模块创建新的进程，
并收集足够多的信息交给进程，由新的进程进行处理并返还结果。所有非专业内容。比如
拼写/字数检查、缩进、格式调整、版本管理、编译和调试都会采用进程间协作的方式完
成。VimE只会处理文本操作，除此以外的所有功能（甚至显示的方式、比如生成位图什么
的）都会交给模块和外部进程。


==============================================================================
4. 编程风格						*coding-style*

VimE的核心采用ANSI的编程风格。以下所有的规则都是添加、删除、修改VimE核心代码必
须遵循的准则，否则会受到社区的冷遇，或者会被当作扩展模块而不会被加入VimE核心。
请坚持使用这些原则。

这个列表是不完全的，请查看源代码以获得更多的例子。


修 改 代 码						*style-changes*

修改代码的基本步骤：
	1. 首先调整文档，先添加开发文档，再修改用户文档，这样将会为整个修改行
	   为添加一个大纲，并对更改如何影响核心有一个整体的印象。
	2. 改变源代码。
	3. 检查todo list和开发wiki，看看所在的修改是否影响其中的项目。
	4. 用 "diff -c" 针对没有改变的代码和文档，做一个补丁。
	5. 向社区说明为何进行这样的修改，并写一个修改总结和记录，并把它们加入
	   到补丁中。


普 通 函 数 的 使 用					*style-functions*

VimE会对一些普通函数提供封装，以获得更好的效率。一般情况下这种封装会以层的形式
存在。VimE的核心不应有依赖任何假设。在完成工作时，可以先使用ANSI标准函数，如果
需要任何操作系统相关的服务，先添加操作系统抽象层的API，再添加操作系统相关的代
码，最后再在核心里使用层提供的API。如果发现任何ANSI标准函数有VimE提供的版本（
会在开发wiki中注明），请使用VimE提供的版本。通常这意味着移植性或者健壮性。在得
到补丁的时候，我们会审核你调用的任何函数，任何不在VimE抽象层中的函数调用都是不
允许的（也就是说，不允许在VimE核心里面直接调用任何操作系统或者第三方库的函数）
。


命 名							*style-names*

我们不鼓励匈牙利命名法，函数内变量可以随意地命名，但所有函数名必须是全小写字母
和下划线的组合。可以通过后缀说明函数的参数，但是不提倡这么做。函数名不超过31个
字符的长度。API函数采用v_模块名_对象_操作的方式命名，其中对象可以省略，但如果
省略对象，则函数必须不接受除self以外的任何参数。（self是指当前模块的一个状态控
制块，比如struct vime_mode，它并不强制命名为self，但是必须是每个API的第一个参
数）

因为 VimE 需要在尽可能多的平台上运行，所以我们需要避免那些已经被系统定义过的名
称。这里是一个已知会造成麻烦的名称列表 (使用正规表达式模式给出)。

is.*()		POSIX，ctype.h
to.*()		POSIX，ctype.h

d_.*		POSIX，dirent.h
l_.*		POSIX，fcntl.h
gr_.*		POSIX，grp.h
pw_.*		POSIX，pwd.h
sa_.*		POSIX，signal.h
mem.*		POSIX，string.h
str.*		POSIX，string.h
wcs.*		POSIX，string.h
st_.*		POSIX，stat.h
tms_.*		POSIX，times.h
tm_.*		POSIX，time.h
c_.*		POSIX，termios.h
MAX.*		POSIX，limits.h
__.*		POSIX，system
_[A-Z].*	POSIX，system
E[A-Z0-9]*	POSIX，errno.h

wait		不要使用它作为函数的参数，和 types.h 冲突
index		屏蔽全局声明
time		屏蔽全局声明
new		C++ 保留关键字
try		Borland C++ 不希望它作为变量名被使用。

basename()	GNU 串函数
dirname()	GNU 串函数
get_env_value()	Linux 系统函数


这些是对内部static函数的限制。API必须按照上述方式命名。如果必须暴露非API的内部
函数，则函数必须以双下划线开头。

常量式的宏只允许由大写字母、数字和下划线组成，而操作式的宏命名规则同函数，理由
是可能在未来它们可能以函数的形式提供。


typedef不是必须的。通常的规则是，如果是单个基本类型，则在API中必须typedef，而
且typedef的名称必须以_t结尾。如果是结构体，则如果各个成员之间没有内在的逻辑相
连性，则不用typedef（比如struct point { int x, y; };），否则必须做typedef。共
用体必须typedef（因为它的各个成员总是会有内在的相连性），而枚举不允许被typedef
。

允许在API层使用和暴露全局变量，但是所有暴露出的全局变量只允许是可读的，如果要
求可读可写，由一对API函数代替。

特性是由配置变量控制的。配置变量必须是以VIME_CONFIG_打头的宏： >
	#define VIME_CONFIG_FOO
<

预 处 理 指 令						*style-preprocess*

如果不是绝对需要，不允许在函数内部使用#if块。考虑用 >
	#ifdef FOO
	void foo()
	{
	    ....
	}
	#else
	void foo() {}
	#endif
<
代替，这样空的函数调用会被优化掉。而函数内部不会使用#if块。如果#if是操作系统相
关的。优先考虑在操作系统层提供通用的API，通常情况下不允许直接在核心中使用#if判
断操作系统。因为这容易掩盖操作系统抽象层的错误。

定义函数式的宏需要谨慎，如果是在单个翻译单元使用，考虑使用内联的静态函数。可以
利用预处理提供编译器相关的内联指令以达到最好效果。如果必须要通过宏使用，则必须
在宏的定义处写明对参数的任何需求（比如不能有副作用）。

尽量用预定义配置的方式定义常量，如果必须在单个头文件定义，则应该先检测是否已被
预定义，并采用相应措施（放弃定义，或者undef，或者#error）。


缩 进							*style-indention*

采用4个空格的缩进，所有的缩进都使用空格。不允许TAB和空格混合的缩进方式。所有的
代码不能超过80列。函数尽量不超过100行。如果单个函数超过100行，考虑静态内联函数
。


==============================================================================
5. 假定							*design-assumptions*

在核心内部，不应该有对类型大小的依赖。如果确实存在这种依赖，那么必须使用
stdint.h中定义的类型。在不存在这个平台的对应头文件，则应该在对应平台的include
文件夹内提供这个头文件。


 vim:tw=78:ai:sw=8:ts=8:ft=help:norl:
